{
  "version": 3,
  "sources": ["../../.pnpm/@lexical+link@0.32.1/node_modules/@lexical/link/LexicalLink.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, isHTMLAnchorElement, $findMatchingParent } from '@lexical/utils';\nimport { createCommand, ElementNode, $isRangeSelection, $applyNodeReplacement, $isElementNode, $getSelection, $isNodeSelection, $normalizeSelection__EXPERIMENTAL, $setSelection } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url = '', attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    this.updateLinkDOM(null, element, config);\n    addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n  updateLinkDOM(prevNode, anchor, config) {\n    if (isHTMLAnchorElement(anchor)) {\n      if (!prevNode || prevNode.__url !== this.__url) {\n        anchor.href = this.sanitizeUrl(this.__url);\n      }\n      for (const attr of ['target', 'rel', 'title']) {\n        const key = `__${attr}`;\n        const value = this[key];\n        if (!prevNode || prevNode[key] !== value) {\n          if (value) {\n            anchor[attr] = value;\n          } else {\n            anchor.removeAttribute(attr);\n          }\n        }\n      }\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    this.updateLinkDOM(prevNode, anchor, config);\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);\n  }\n  sanitizeUrl(url) {\n    url = formatUrl(url);\n    try {\n      const parsedUrl = new URL(formatUrl(url));\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      url: this.getURL()\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n    return writable;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n    return writable;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n    return writable;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n    return writable;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n  isEmailURI() {\n    return this.__url.startsWith('mailto:');\n  }\n  isWebSiteURI() {\n    return this.__url.startsWith('https://') || this.__url.startsWith('http://');\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url = '', attributes) {\n  return $applyNodeReplacement(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n\n  constructor(url = '', attributes = {}, key) {\n    super(url, attributes, key);\n    this.__isUnlinked = attributes.isUnlinked !== undefined && attributes.isUnlinked !== null ? attributes.isUnlinked : false;\n  }\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      isUnlinked: node.__isUnlinked,\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  getIsUnlinked() {\n    return this.__isUnlinked;\n  }\n  setIsUnlinked(value) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n  createDOM(config) {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;\n  }\n  static importJSON(serializedNode) {\n    return $createAutoLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url = '', attributes) {\n  return $applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = createCommand('TOGGLE_LINK_COMMAND');\nfunction $getPointNode(point, offset) {\n  if (point.type === 'element') {\n    const node = point.getNode();\n    if (!$isElementNode(node)) {\n      formatDevErrorMessage(`$getPointNode: element point is not an ElementNode`);\n    }\n    const childNode = node.getChildren()[point.offset + offset];\n    return childNode || null;\n  }\n  return null;\n}\n\n/**\n * Preserve the logical start/end of a RangeSelection in situations where\n * the point is an element that may be reparented in the callback.\n *\n * @param $fn The function to run\n * @returns The result of the callback\n */\nfunction $withSelectedNodes($fn) {\n  const initialSelection = $getSelection();\n  if (!$isRangeSelection(initialSelection)) {\n    return $fn();\n  }\n  const normalized = $normalizeSelection__EXPERIMENTAL(initialSelection);\n  const isBackwards = normalized.isBackward();\n  const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);\n  const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);\n  const rval = $fn();\n  if (anchorNode || focusNode) {\n    const updatedSelection = $getSelection();\n    if ($isRangeSelection(updatedSelection)) {\n      const finalSelection = updatedSelection.clone();\n      if (anchorNode) {\n        const anchorParent = anchorNode.getParent();\n        if (anchorParent) {\n          finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), 'element');\n        }\n      }\n      if (focusNode) {\n        const focusParent = focusNode.getParent();\n        if (focusParent) {\n          finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), 'element');\n        }\n      }\n      $setSelection($normalizeSelection__EXPERIMENTAL(finalSelection));\n    }\n  }\n  return rval;\n}\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nfunction $toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = $getSelection();\n  if (selection === null || !$isRangeSelection(selection) && !$isNodeSelection(selection)) {\n    return;\n  }\n  if ($isNodeSelection(selection)) {\n    const nodes = selection.getNodes();\n    if (nodes.length === 0) {\n      return;\n    }\n\n    // Handle all selected nodes\n    nodes.forEach(node => {\n      if (url === null) {\n        // Remove link\n        const linkParent = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (linkParent) {\n          linkParent.insertBefore(node);\n          if (linkParent.getChildren().length === 0) {\n            linkParent.remove();\n          }\n        }\n      } else {\n        // Add/Update link\n        const existingLink = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (existingLink) {\n          existingLink.setURL(url);\n          if (target !== undefined) {\n            existingLink.setTarget(target);\n          }\n          if (rel !== undefined) {\n            existingLink.setRel(rel);\n          }\n        } else {\n          const linkNode = $createLinkNode(url, {\n            rel,\n            target\n          });\n          node.insertBefore(linkNode);\n          linkNode.append(node);\n        }\n      }\n    });\n    return;\n  }\n\n  // Handle RangeSelection\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parentLink = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n      if (parentLink) {\n        const children = parentLink.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parentLink.insertBefore(children[i]);\n        }\n        parentLink.remove();\n      }\n    });\n    return;\n  }\n  const updatedNodes = new Set();\n  const updateLinkNode = linkNode => {\n    if (updatedNodes.has(linkNode.getKey())) {\n      return;\n    }\n    updatedNodes.add(linkNode.getKey());\n    linkNode.setURL(url);\n    if (target !== undefined) {\n      linkNode.setTarget(target);\n    }\n    if (rel !== undefined) {\n      linkNode.setRel(rel);\n    }\n    if (title !== undefined) {\n      linkNode.setTitle(title);\n    }\n  };\n  // Add or merge LinkNodes\n  if (nodes.length === 1) {\n    const firstNode = nodes[0];\n    // if the first node is a LinkNode or if its\n    // parent is a LinkNode, we update the URL, target and rel.\n    const linkNode = $getAncestor(firstNode, $isLinkNode);\n    if (linkNode !== null) {\n      return updateLinkNode(linkNode);\n    }\n  }\n  $withSelectedNodes(() => {\n    let linkNode = null;\n    for (const node of nodes) {\n      if (!node.isAttached()) {\n        continue;\n      }\n      const parentLinkNode = $getAncestor(node, $isLinkNode);\n      if (parentLinkNode) {\n        updateLinkNode(parentLinkNode);\n        continue;\n      }\n      if ($isElementNode(node)) {\n        if (!node.isInline()) {\n          // Ignore block nodes, if there are any children we will see them\n          // later and wrap in a new LinkNode\n          continue;\n        }\n        if ($isLinkNode(node)) {\n          // If it's not an autolink node and we don't already have a LinkNode\n          // in this block then we can update it and re-use it\n          if (!$isAutoLinkNode(node) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node))) {\n            updateLinkNode(node);\n            linkNode = node;\n            continue;\n          }\n          // Unwrap LinkNode, we already have one or it's an AutoLinkNode\n          for (const child of node.getChildren()) {\n            node.insertBefore(child);\n          }\n          node.remove();\n          continue;\n        }\n      }\n      const prevLinkNode = node.getPreviousSibling();\n      if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {\n        prevLinkNode.append(node);\n        continue;\n      }\n      linkNode = $createLinkNode(url, {\n        rel,\n        target,\n        title\n      });\n      node.insertAfter(linkNode);\n      linkNode.append(node);\n    }\n  });\n}\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\nconst PHONE_NUMBER_REGEX = /^\\+?[0-9\\s()-]{5,}$/;\n\n/**\n * Formats a URL string by adding appropriate protocol if missing\n *\n * @param url - URL to format\n * @returns Formatted URL with appropriate protocol\n */\nfunction formatUrl(url) {\n  // Check if URL already has a protocol\n  if (url.match(/^[a-z][a-z0-9+.-]*:/i)) {\n    // URL already has a protocol, leave it as is\n    return url;\n  }\n  // Check if it's a relative path (starting with '/', '.', or '#')\n  else if (url.match(/^[/#.]/)) {\n    // Relative path, leave it as is\n    return url;\n  }\n\n  // Check for email address\n  else if (url.includes('@')) {\n    return `mailto:${url}`;\n  }\n\n  // Check for phone number\n  else if (PHONE_NUMBER_REGEX.test(url)) {\n    return `tel:${url}`;\n  }\n\n  // For everything else, return with https:// prefix\n  return `https://${url}`;\n}\n\nexport { $createAutoLinkNode, $createLinkNode, $isAutoLinkNode, $isLinkNode, $toggleLink, AutoLinkNode, LinkNode, TOGGLE_LINK_COMMAND, formatUrl, toggleLink };\n"],
  "mappings": "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",
  "names": ["nodes"]
}
